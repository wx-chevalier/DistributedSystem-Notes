# 1. 高级分布式系统

> 分布式编程是一门能让你在多台计算机上解决问题就如同在一台主机上一样的艺术。

任何计算机系统都需要完成以下两个基本任务：

- 存储
- 计算

分布式编程是一门能让你在多台计算机上解决问题就如同在一台主机上一样的艺术 —— 通常情况下是因为单台计算机的性能已经不足以解决当前问题了。

事实上并没有什么需求让你必须使用分布式系统。假设拥有无限的开发时间和经费，我们完全不需要使用分布式系统。所有的计算和存储我们都可以在一个小小的魔盒中完成——这是一个*专门为你设计的*快速而且可靠的单机系统。

然而，很少有人能够拥有无限的资源。 因此，他们不得不在现实世界中的成本—效益曲线上找到一个合适的位置。在小规模的情况下，升级硬件是一个切实可行的方案。然而，随着问题规模的扩大，你将会达到硬件升级的瓶颈——你已经无法再对该结点升级或者升级的成本大大提高难以为继。如果你现在正处于当前这个状态，那么，欢迎你来到分布式的世界。

目前的现状是，性价比最高的是中端商用硬件，我们只需要通过容错软件就能使其维护成本大大降低。

计算主要受益于高端硬件，以至于其可以用内部存储器访问来取代缓慢的网络访问。但在节点间需要大量通信的任务中，高端硬件的性能优势却受到了限制。

![cost-efficiency](./image/barroso_holzle.png)

如[Barroso, Clidaras & Hölzle](http://www.morganclaypool.com/doi/abs/10.2200/S00516ED2V01Y201306CAC024)的上图所示， 假设所有节点都采用统一的内存访问模式，那么高端硬件和商品级硬件之间的性能差距将随着集群规模的增加而减小

在理想情况下，添加一台新机器将使系统的性能和容量呈线性增加。但这显然是不可能的，因为计算机会产生一些额外的开销。数据需要被复制，计算任务需要被协调，诸如此类。这就是为什么研究分布式算法是值得的——它们为具体问题提供了有效的解决方案，除此之外也指导了什么是可行的，正确实现的最小成本是什么以及什么是不可行的。

本文的重点是分布式系统与编程，为此我们需要一个普通的，但又与商业密切相关的环境：数据中心。因此，举例来说我们将不会讨论由于某个异乎寻常的网络配置或者因为共享内存设置而产生的某种特殊问题。此外，我们的重点是探索系统架构，而不是针对任何特定的架构进行优化——后者有一个专门的主题来讨论这个。 

## 我们想要实现的目标: 可扩展性与其他优点

依我所见，一切都始于处理规模 *(size)* 的需要。

大多数事物在小尺度时都是微不足道的——但当你的事物一旦超过一定的大小、体积或其他物理约束时，同样的问题就会变得困难得多。这就如同你可以轻而易举的举起一块巧克力，但完全不可能举起一座山。又比如你可以迅速的数清房间里究竟有多少人，但你很难知道这个国家究竟有多少人。诸如此类。

所以，一切都要从规模——可扩展性说起。通俗地说，在一个可扩展的系统中随着我们规模的变大，事情并不应该逐渐变差。这有另一个定义：

- [可扩展性](http://en.wikipedia.org/wiki/Scalability)是一个系统、网络或者进程的能力，使其能够处理越来越多的工作或者其能够被扩展以适应这种增长。


那么是什么在增长呢？嗯，你可以用任何术语来衡量增长（人口数量、用电量等）。但是我们一般主要用以下三点来进行衡量：

- 规模扩展性: 添加更多的结点将使系统响应速度呈线性增快; 同时增长的数据集不应增加延迟。
- 地域扩展性: 应该使用多个数据中心来减少用户查询的响应时间, 同时以某种合理的方式处理跨数据中心的延迟。
- 管理扩展性: 添加更多的结点不应该增加系统的管理成本（例如管理员与机器的比例）。

当然, 在一个真实的系统中，增长将同时发生在多个不同的维度上; 每个指标也都只反映了增长的某些方面。

一个可扩展的系统应该随着用户规模的增加而持续满足用户的需求。其中有两个特别相关的方面——性能和可用性——可以用不同的方式来衡量。

### 性能(与延迟)

- [性能](http://en.wikipedia.org/wiki/Computer_performance)的特征是计算机系统完成的有效工作量与其使用的时间和资源的比值。


根据具体情况，这可能涉及实现以下一项或多项目标：

- 某项工作的响应时间短/延迟低
- 高吞吐量 (处理工作的速率)
- 计算资源利用率低

在对这些目标中的任何一个进行优化时都需要权衡取舍。例如，系统可以通过使用更大的批处理方式来实现更高的吞吐量，从而减少操作开销。但这种折衷方式将会使单个工作的响应时间变长。

我发现低延迟——缩短响应时间——是性能中最令人关注的部分，因为它与物理（而非经济）限制密切相关。与性能的其他方面相比，使用财政资源处理延迟更困难。

对于延迟有很多非常具体的定义，但我喜欢下面这个依据词源的解释：

- 延迟 *(Latency)*

  是一种潜在 *(Latent)* 的状态; 即某件事从开始到发生之间的一段时间。

那么“潜在”是什么意思呢？

- 潜在  *(Latent)*

  其来源于拉丁语伪装 *(latens)* 和隐藏 *(latentis)* ，它的现在分词形式是 *lateo* （“隐藏”）。指现存的但已经被隐藏或尚不活跃的。

这个定义非常的酷，因为它强调了延迟 *(latency)* 是指从某个事件发生到受该事件影响或使其变得可见之间的时间。

例如，假设你感染了一种由空气传播的病毒，它能把人变成僵尸。潜伏期 *(latent)* 就是你感染后到变成僵尸之间的这段时间。 这就是延迟 *(latency)* ：即当事情已经发生但其被隐藏起来而致使不能观察到的这段时间。

现在让我们假设我们的分布式系统只执行一项高级任务：给定一个查询，它将获取系统中的所有数据并计算出一个结果。换句话说，可以将分布式系统看作是能够在当前内容上运行单确定性计算(函数)的数据存储。

`result = query(all data in the system)`

那么，延迟的关键不是旧数据的数量，而是新数据在系统中“生效”的速度。例如，延迟可以根据从写入数据到读取可见之间所花费的时间来度量。

基于这个定义的另一个关键点是，如果什么事都没发生，那自然就没有“潜伏期 *(latent period)* ”。数据不改变的系统不会(也不应该)有延迟问题。

在分布式系统中，存在一个无法克服的最小延迟：因为光速限制了信息传输的速度；与此同时硬件的每次运行也会有一个最小延迟（比如RAM和硬盘，还有CPU）。

最小延迟对查询的影响主要取决于这些查询的性质以及这些信息所需要传输的物理距离。

### 可用性（与容错性）

可扩展系统的第二个方面是可用性。

- [可用性](http://en.wikipedia.org/wiki/High_availability)

  是指系统处于正常运行状态的时间比例。如果一个用户不能访问该系统，则我们称之为不可用。

分布式系统使我们能够实现在单个系统上难以实现的理想特性。例如，一台机器不能容忍任何故障，因为它要么失败要么成功。

而分布式系统则正是基于一堆不可靠的组件，并在此基础之上试图构建一个可靠的系统。

因此没有冗余的系统只能作为其底层组件使用。 相反使用冗余构建的系统可以容忍部分故障，从而使其增加可用性。值得注意的是，“冗余”可能意味着不同的东西，比如组件、服务器、数据中心等等，诸如此类。

使用公式表示: `Availability = uptime / (uptime + downtime)`.

从技术角度来看，可用性主要是指容错性。因为故障出现的概率会随着组件数量的增加而增加，因此系统应该能够提供补偿机制，以使其可靠性不会随着组件数量的增加而降低。

例如:

| 可靠性%             | 每年允许多少宕机时间? |
| ------------------- | --------------------- |
| 90% ("一个九")      | 超过一个月            |
| 99% ("两个九")      | 少于4天               |
| 99.9% ("三个九")    | 少于9小时             |
| 99.99% ("四个九")   | 少于1小时             |
| 99.999% ("五个九")  | ~ 5分钟               |
| 99.9999% ("六个九") | ~ 31秒                |

可用性在某种意义上来说是比正常运行时间更为宽泛的概念，因为服务的可用性也可能受到网络中断或拥有该服务的公司的业务中断的影响（这将是一个与容错无关的因素，但仍然会影响系统的可用性）。但是，我们并不能了解系统的每一个具体方面，所以我们所能做的最好方式就是设计容错性。

什么是容错性？

- 容错性

  是指当故障发生时，系统能够以一种明确的方式继续运行的能力。

容错性可以归结为：先定义你所期望的故障，然后设计一个针对该故障的容错系统或算法。因此你不能对一个你没有考虑过的错误进行容错。

## 是什么阻碍了我们获得美好的事物呢？

分布式系统受到两个物理因素的制约：

- 结点的数量 (随着所需存储和计算能力的增加而增加)
- 两个结点间的距离(信息最多只能以光速传播)

因此在这些约束下工作会导致以下三点:

- 随着独立节点数量的增加会增加系统故障的概率（降低可用性并增加管理成本）
- 随着独立节点数量的增加可能会增加节点间通信的需求（随着规模的增加而降低性能）
- 随着地理距离的增加而增加了远距离节点之间通信的最小延迟（降低某些操作的性能）

除了以上这三点之外——这是由物理约束导致的结果——是系统设计方案的世界。

性能和可用性都是由系统所提供的外部保证来定义的。从高层次上讲，你可以将这些保证看作是系统的SLA(服务级别协议)：假设我写入数据，那么我可以在其他地方快速访问它吗?数据写入后，我拿什么保证数据的持久性？如果我要求系统运行一个计算，那么它返回结果的速度到底有多快?当组件运行失败或停止运行时，这又会对系统产生什么影响？

还有另一个标准，虽然没有明确提到，但隐含在其中：可理解性 *(intelligibility)* 。所做的这些保证有多容易理解呢？当然，什么是可理解性，没有简单的衡量标准。

我很想将“可理解性”归入物理限制之下。毕竟，对于人来说，这是一个硬件限制，我们需要很长的一段的时间来理解它，[因为其并不像移动我们的手指那般简单](http://en.wikipedia.org/wiki/Working_memory#Capacity).。这就是错误和异常的区别——错误是不正确的行为，而异常是意外行为。如果你足够聪明，你应该会预料到异常的发生。

## 抽象与模型

这就到了抽象和模型发挥作用的地方。抽象通过移除与解决问题无关的现实方面，从而使事情更易于管理。 模型则是以一种精确的方式来描述分布式系统的关键属性。下一章我将讨论多种模型，比如：

- 系统模型（异步/同步）
- 故障模型（崩溃，分区，拜占庭问题）
- 一致性模型（强一致性，最终一致性）

因此一个好的抽象可以使系统更加容易理解，同时也可以捕捉到与特定目的相关的因素。

现实中多个结点和我们希望系统能“如同一个系统一样工作”的渴望之间往往存在着对立关系。通常，最熟悉的模型（例如，在分布式系统上实现共享内存抽象）往往成本过于昂贵了。

而一个保证较弱的系统则会具有更高的行动自由度，因此其可能具有更高的性能——但这也导致其更难以理解。 人们更容易理解单系统，而非节点集合的系统。

人们通常可以通过公开关于系统内部的更多细节来获得性能的提升。例如，在[列式存储](http://en.wikipedia.org/wiki/Column-oriented_DBMS)中，用户可以（在某种程度上）分析系统内键值对的位置，从而做出影响典型查询性能的决策。因而隐藏这些细节的系统会更容易理解（因为它们更像单个单元，而不需要考虑太多细节），相反暴露更多现实世界细节的系统可能具有更好的性能（因为它们更符合实际）。

一些类型的失败使得编写一个如同单一系统一样的分布式系统变得极其困难。网络延迟和网络分区（例如全部网络之中总有一些结点之间会出现故障）意味着系统有时需要做出艰难的选择，即是否保持更好的可用性，但同时失去一些无法执行的重要保证，或当此类故障发生时为了保证它的数据安全性而拒绝客户端。

这就是CAP定理——我将会在下一章讨论这个——用以描述这些对立关系。最终，理想的系统应该同时满足程序员的需求（简洁的语义 *(clean semantics)* ）和业务需求（可用性/一致性/延迟）。

## 设计技巧：分区和复制

数据集在多个节点之间分布的方式非常重要。 为了使我们能应对任何计算的发生，我们需要找到数据并对其进行处理。

有两种基本技术可以应用于我们的数据集。一种方式是拆分到多个节点上，以便其能进行更多的并行处理——分区。另一种方式是在不同的节点上复制或缓存所有数据，以减少客户端和服务器之间的距离并提高容错能力——复制。

> 分而治之 - 即分区与复制

下图说明了这两者之间的区别：使用分区方式处理的数据（下面的A和B）被分成几个独立的数据集，而采用复制方式处理的数据（下面的C）被复制到多个位置。

![Partition and replicate](./image/part-repl.png)

这两种方式的组合使用在解决分布式计算问题中扮演着重要的角色。当然，这其中的诀窍在于为你的具体实现选择一种合适的技术; 现在有许多算法可以实现复制与分区，但每种算法也都有着各自不同的优势和局限，这需要根据你的设计目标来进行评估。

### 分区技术

分区技术是指将原数据集划分为更小的独立数据集；这是用来减少数据集增长所带来的影响，因为每个分区是原数据的一个子集。

- 分区是通过限制要使用的数据量并通过在相同分区中定位相关数据来提高其性能。
- 分区是通过允许分区独立失败来提高其可用性，因此可以通过增加节点数量来减少失败。

分区技术也是依赖于特定的应用程序的，所以在不知道具体细节的情况下很难对其进行说明。 这就是为什么大多数文章中都把重点放在复制部分，当然也包括本文。

分区技术主要是根据你认为的主要访问模式来定义你的分区，并处理独立分区带来的限制（例如跨分区的低效访问，不同的增长率等）。

### 复制技术

复制技术是指在多台机器上制作相同数据的副本；从而允许更多的服务器参与计算。

让我大致引用一下 [Homer J. Simpson](http://en.wikipedia.org/wiki/Homer_vs._the_Eighteenth_Amendment) 的话：

> 复制！生活中所有问题的成因和解决方法。

复制——拷贝某些内容——是我们对抗延迟的主要方式。

- 复制通过增加适用于新数据副本的计算能力和带宽来提高性能。
- 复制可以通过创建额外的数据副本来提高可用性，因此可以通过增加节点数量来增加可用性。

复制是为了提供额外的带宽，并在重要的地方进行缓存。它会根据某种一致性模型然后以某种方式来保持数据的一致性。

复制技术允许我们实现可扩展性、性能和容错性。害怕失去可用性或降低系统性能？复制数据可以避免瓶颈或单点故障。缓慢的计算？我们可以在多个系统上进行复制计算。慢速I/O？我们可以将数据复制到本地缓存从而减少延迟或复制到到多台机器上以增加吞吐量。

复制技术也是许多问题的根源，因为现在独立的数据副本必须在多台机器上保持同步——这意味着必须确保复制遵循一致性模型。

一致性模型的选择至关重要：良好的一致性模型为程序员提供了简洁的语义（换句话说，它所保证的属性很容易理解），并满足了诸如高可用性或强一致性等业务/设计目标。

只有强一致性模型——它允许你如同底层数据并没有被复制到多个结点一样来进行编程。其他一致性模型都需要向程序员公开一些复制的内部细节。然而，较弱的一致性模型可以提供更低的延迟和更高的可用性，并且不一定更难理解，只是不同而已。



------

## 扩展阅读

- [The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines](http://www.morganclaypool.com/doi/pdf/10.2200/s00193ed1v01y200905cac006) - Barroso & Hölzle, 2008
- [Fallacies of Distributed Computing](http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing)
- [Notes on Distributed Systems for Young Bloods](http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/) - Hodges, 2013