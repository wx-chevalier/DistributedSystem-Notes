![default](https://user-images.githubusercontent.com/5803001/45228854-de88b400-b2f6-11e8-9ab0-d393ed19f21f.png)

# 数据库设计

## 设计范式

### 第一范式(确保每列保持原子性)

第一范式是最基本的范式，简而言之，第一范式就是无重复的列。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式(1NF)中表的每一行只包含一 个实例的信息。在任何一个关系数据库中，第一范式(1NF)是对关系模式的基本要求，不满足第一范式(1NF)的数据库就不是关系数据库。
第一范式的合理遵循需要根据系统的实际需求来 定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城 市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算 满足了数据库的第一范式，如下表所示。
![](http://pic002.cnblogs.com/images/2012/270324/2012040114023352.png)

### 第二范式(2NF)属性完全依赖于主键(消除部分子函数依赖)

第二范式(2NF)是在第一范式(1NF)的基 础上建立起来的，即满足第二范式(2NF)必须先满足第一范式(1NF)。第二范式(2NF)要求数据库表中的每个实例或行必须可以被惟一地区分。为实现 区分通常需要为表加上一个列，以存储各个实例的惟一标识。
例如员工信息表中加上了员工编号(emp_id)列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。
第二范式(2NF)要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的 这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。
比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。
![](http://pic002.cnblogs.com/images/2012/270324/2012040114063976.png)
这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。
而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。
![](http://pic002.cnblogs.com/images/2012/270324/2012040114082156.png)

### 第三范式(3NF)属性不依赖于其它非主属性[消除传递依赖]

满足第三范式(3NF)必须先满足第二范式(2NF)。简而言之，第三范式(3NF)要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号(dept_id)、部门名称、部门简介等信息。
那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式(3NF)也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。

# 数据库

# 表

## 索引与外键

# 链接

- https://mp.weixin.qq.com/s/11dorpD57vtUF2bhucveYg
- https://mp.weixin.qq.com/s/MNjrjEivjQpVx40C00nPtw
